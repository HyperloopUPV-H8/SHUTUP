#pragma once

#include "Timer.hpp"
#include "Can.hpp"
#include "Models/Pin.hpp"
#include "AnalogIn.hpp"
#include "InputCapture.hpp"
#include "DigitalIn.hpp"
#include <optional>
#include <vector>
#include <map>

using namespace std;

enum State{
	FREE,
	OCCUPIED
};

class StreamMessage{
public:
	static unsigned int message_index;
	size_t total_size = 0;
	vector<size_t> sizes;
	vector<void*> ptrs;

	template<typename Arg1, typename... Rest>
	StreamMessage(Arg1* arg1, Rest*... args){
		total_size += sizeof(Arg1);
		sizes.push_back(sizeof(Arg1));
		ptrs.push_back(arg1);
		if(sizeof...(args) == 0){
			return;
		}else{
			StreamMessage(args...);
		}
	}

	StreamMessage(){}

	void unparse(uint8_t* d){
		for(int i = 0; i < sizes.size(); i++){
			memcpy(d, ptrs[i], sizes[i]);
			d+= sizes[i];
		}
	}

	// TODO -> abstract all Read services

	static StreamMessage* FromAnalogIn(AnalogIn* in){
		return new StreamMessage(&in->voltage);
	}

	static StreamMessage* FromDigigalIn(DigitalIn* in){
		return new StreamMessage(&in->state);
	}

	static StreamMessage* FromInputCapture(InputCapture* in){
		return new StreamMessage(&in->frequency, &in->duty);
	}

	static optional<StreamMessage*> FromPin(Pin* pin){
		if(pin->mode == ANALOG_INPUT)
			return FromAnalogIn(AnalogIn::analog_in_from_pin[pin]);
		if(pin->mode == DIGITAL_INPUT)
			return FromDigigalIn(DigitalIn::pin_to_digital_in[pin]);
		if(pin->mode == INPUT_CAPTURE)
			return FromInputCapture(InputCapture::pin_to_input_capture[pin]);
	}

};

class Stream {
private:
	static uint8_t current_id;
	static vector<Stream*> streams;
	vector<StreamMessage*> messages;
	unsigned int size = 0;
	uint8_t id;
	Timer* timer;
	Can* can;

	bool is_available(unsigned int frequency, unsigned int size){
		bool is_not_occupied	= this ->state == FREE;
		bool is_not_fulL		= (this->size + size) <= 64 ;
		bool frequencies_match	= this->frequency == frequency;
		return is_not_full && frequencies_match;
	}

public:
	State state = FREE;
	uint32_t frequency;

	Stream(Timer* timer, Can* can) : timer(timer), can(can) {
		Stream::streams.push_back(this);
		id = current_id;
		current_id ++;
	}

	void send_all_messages(){
//		uint8_t d[size];
//		unsigned int current_position = 0;
//		for(auto message : messages){
//			message->unparse(&Can[current_position]);
//			current_position += message->total_size;
//		}
//
//		can->send_message(id, d, size);
	}

	void add_message(uint32_t frequency, StreamMessage* message){
		messages.push_back(message);
		if(state == FREE){
			state = OCCUPIED;
			timer->execute_at([&](){ send_all_messages(); }, frequency);
		};
		this -> frequency = frequency;
		can->send_message(READ_STREAM_ID, (uint8_t*) &id, sizeof(id));
		size += message->total_size;
	}

	static void add_stream(unsigned int frequency, Pin* pin) {
		for(auto s : streams){
			if(s->state == FREE || frequency == s->frequency){
				StreamMessage* message = StreamMessage::FromPin(pin).value();
				s->add_message(frequency, message);
				return;
			}
		}
	}

};
