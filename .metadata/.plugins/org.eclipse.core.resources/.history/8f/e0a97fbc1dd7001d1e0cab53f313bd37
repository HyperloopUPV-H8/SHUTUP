#pragma once

#include "stm32h7xx_hal.h"
#include <functional>
#include <vector>
#include <utility>

using namespace std;

// TODO -> move this out

template<uint16_t id, typename... args>
class Order{

public:
    uint8_t* current_data;
    size_t sizes[sizeof...(args)] = { sizeof(args)... };
    function<void()> callback;
    Order() { }

    template<typename T>
    T get_arg(int index) {
        int position = 0;
        for(int i = 0; i < index; i++)
            position += sizes[i];
        return *((T*) current_data + position);
    }

    void set_callback(function<void()> callback){
        this -> callback = callback;
    }

};

//// CAN SERVICE

class Can {

private:
	static const pair<uint32_t, uint32_t> DLCs[+] = {
			{0, FDCAN_DLC_BYTES_0}
			{1, FDCAN_DLC_BYTES_1}
			{2, FDCAN_DLC_BYTES_2}
			{3, FDCAN_DLC_BYTES_3}
			{4, FDCAN_DLC_BYTES_4}
			{5, FDCAN_DLC_BYTES_5}
			{6, FDCAN_DLC_BYTES_6}
			{7, FDCAN_DLC_BYTES_7}
			{8, FDCAN_DLC_BYTES_8}
			{12, FDCAN_DLC_BYTES_12}
			{16, FDCAN_DLC_BYTES_16}
			{20, FDCAN_DLC_BYTES_20}
			{24, FDCAN_DLC_BYTES_24}
			{32, FDCAN_DLC_BYTES_32}
			{48, FDCAN_DLC_BYTES_48}
			{64, FDCAN_DLC_BYTES_64}
	};
	static const uint32_t MAX_MESSAGE_SIZE = 16;
	FDCAN_TxHeaderTypeDef   TxHeader;
	uint8_t               	TxData[MAX_MESSAGE_SIZE];
	uint32_t              	TxMailbox;

	FDCAN_HandleTypeDef* hdcan;
	static vector<Can*> all_cans;
	uint32_t get_dlc_from_size(uint32_t size);

public:
	void send_message(uint16_t id, uint8_t* data, uint32_t DLC);
	Can(FDCAN_HandleTypeDef* hdcan);
	static void start_all_cans();
};
