#include "Mini-STLIB/InputCapture.hpp"

vector<InputCapture> InputCapture::all_input_captures;

InputCapture::InputCapture(TIM_HandleTypeDef* timer, uint32_t channel, GPIO_TypeDef* port, uint16_t pin)
: timer(timer), channel(channel), port(port), pin(pin) { }

uint32_t InputCapture::absolute_difference(uint32_t a, uint32_t b){
	int result = a - b;
	if(result < 0)
		result = a + (timer->Instance->ARR - b) + 1;
	return result;
}

double InputCapture::interrupt() {
	GPIO_PinState state = HAL_GPIO_ReadPin(port, pin);

	// Capture first rising edge
	if(rising_edge == -1 && falling_edge == -1 && state ==  GPIO_PIN_SET){
		rising_edge = HAL_TIM_ReadCapturedValue(timer, channel);
		return frequency;
	}

	// Capture falling edge
	if(rising_edge != -1 && falling_edge == -1 && state ==  GPIO_PIN_RESET){
		falling_edge = HAL_TIM_ReadCapturedValue(timer, channel);
		return frequency;
	}

	// Capture second rising edge
	if(rising_edge != -1 && falling_edge != -1 && state ==  GPIO_PIN_SET){
		uint32_t duty_count = absolute_difference(falling_edge, rising_edge);
		uint32_t new_rising_edge	= HAL_TIM_ReadCapturedValue(timer, channel);
		uint32_t freq_count = absolute_difference(new_rising_edge, rising_edge);

		DutyAverage.add_value(((double) duty_count) / freq_count * 100);
		FrequencyAverage.add_value(((double) 277777777) / freq_count);
		frequency		= FrequencyAverage.current_value;
		duty			= DutyAverage.current_value;

		frequency_i		= frequency * 10000;
		duty_i			= duty * 10000;

		rising_edge		= -1;
		falling_edge	= -1;
	}

	return frequency;
}

void InputCapture::interrupt_of_all_input_captures(TIM_HandleTypeDef* timer){
	for(auto input_capture : InputCapture::all_input_captures){
		if(input_capture.timer == timer)
			input_capture.interrupt();
	}
}

void InputCapture::reset(){
	frequency = 0;
	duty = 0;
}

void InputCapture::start(){
	HAL_TIM_IC_Start_IT(timer, channel);
}

void InputCapture::stop(){
	HAL_TIM_IC_Stop_IT(timer, channel);
}

