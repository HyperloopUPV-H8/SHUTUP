#pragma once

#include <cstring>
#include <string>
#include <vector>
#include <map>

#define PMW_5V_COUNT 11

using namespace std;

struct Sensor {
	string name;
	TIM_HandleTypeDef* tim;
	uint32_t channel;
	volatile uint32_t* CCR;
};

struct PWM {
	string name;
	TIM_HandleTypeDef* tim;
	uint32_t channel;
	volatile uint32_t* CCR;
};

extern FDCAN_HandleTypeDef hfdcan1;
extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim2;
extern TIM_HandleTypeDef htim3;
extern TIM_HandleTypeDef htim4;
extern TIM_HandleTypeDef htim8;
extern TIM_HandleTypeDef htim12;
extern TIM_HandleTypeDef htim23;
extern TIM_HandleTypeDef htim24;

vector<Sensor> sensors_3v;
vector<PWM> pwm_5v;
uint32_t pwm_5v_result[PMW_5V_COUNT];

uint8_t Is_First_Captured = 0;

uint32_t pwm_01_prev, pwm_01_difference;

map<string, uint32_t> input_capture_values;
map<string, uint32_t> input_capture_differences;

class InputCapture {
private:
	const int COMPRESSION_SIZE = 4;
	TIM_HandleTypeDef* tim;
	uint32_t channel;

	bool toggle = false;

	uint32_t compressed_value;
	uint8_t  decompressed_values[COMPRESSION_SIZE];
	uint32_t frequencies[COMPRESSION_SIZE - 1];


public:
	InputCapture(TIM_HandleTypeDef* tim, uint32_t channel): tim(tim), channel(channel){
		HAL_TIM_IC_Start_DMA(tim, channel,values, 1);
	}

	void read() {
		memcpy(frequencies, values, COMPRESSION_SIZE * 4);
		uint32_t mask;
		for(int i = 0; i < COMPRESSION_SIZE; i++){
			mask = 0b11111111 << (i*8);
			decompressed_values[i] = 0;
		}
	}
};

InputCapture<4>* input_capture_pa1;

class TUDTests{
public:

	static void setup(){

		sensors_3v = {
				{ string("SENSOR 3V 01"), &htim23,	TIM_CHANNEL_2, &htim23.Instance->CCR2	},
				{ string("SENSOR 3V 02"), &htim23,	TIM_CHANNEL_1, &htim23.Instance->CCR1	},
				{ string("SENSOR 3V 03"), &htim2,	TIM_CHANNEL_1, &htim2.Instance->CCR1	},
				{ string("SENSOR 3V 04"), &htim23,	TIM_CHANNEL_3, &htim23.Instance->CCR3 	},
				{ string("SENSOR 3V 05"), &htim8,	TIM_CHANNEL_4, &htim8.Instance->CCR4	},
				{ string("SENSOR 3V 06"), &htim8, 	TIM_CHANNEL_2, &htim8.Instance->CCR2	},
				{ string("SENSOR 3V 07"), &htim2,	TIM_CHANNEL_3, &htim2.Instance->CCR3	},
				{ string("SENSOR 3V 08"), &htim2,	TIM_CHANNEL_4, &htim2.Instance->CCR4	},
				{ string("SENSOR 3V 09"), &htim24,	TIM_CHANNEL_3, &htim24.Instance->CCR3	},
				{ string("SENSOR 3V 10"), &htim24,	TIM_CHANNEL_2, &htim24.Instance->CCR2	},
				{ string("SENSOR 3V 11"), &htim8,	TIM_CHANNEL_3, &htim8.Instance->CCR3	},
				{ string("SENSOR 3V 12"), &htim3,	TIM_CHANNEL_1, &htim3.Instance->CCR1	},
				{ string("SENSOR 3V 13"), &htim12,	TIM_CHANNEL_1, &htim12.Instance->CCR1	},
				{ string("SENSOR 3V 14"), &htim24,	TIM_CHANNEL_4, &htim24.Instance->CCR4	},
				{ string("SENSOR 3V 15"), &htim23,	TIM_CHANNEL_4, &htim23.Instance->CCR4	},
				{ string("SENSOR 3V 16"), &htim24,	TIM_CHANNEL_1, &htim24.Instance->CCR1	},
		};


		for(auto sensor : sensors_3v)
			HAL_TIM_PWM_Start(sensor.tim, sensor.channel);

		input_capture_pa1 = new InputCapture(&htim2, TIM_CHANNEL_2);

	}

	static void loop(){
		for(int i = 0; i < 360; i++){
			for(auto sensor : sensors_3v)
				*sensor.CCR = (uint32_t) (50 +  (sin(i * 3.1415 / 180.0) * 50));
			HAL_Delay(1);
		}

		input_capture_pa1->read();
	}
};
